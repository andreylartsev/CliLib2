DESCRIPTION:

A single file CLI (Command Line Interface) library, similar to picocli but written in C#.
The key idea of a library is a replacement of imperative programming with a declarative one with help of using attribute annotations and reflection.
Where possible used the approach to use the single information source for multiple purposes i.e. 
use class field names to generate command line parameter names, 
environment variable names,  parameters names within app.config, generate embeded app documentaton etc.
The focus is on wider compatibility and minimization of external dependencies.

Supported features:

1. Parsing command line arguments, supported both named and positional parameters;
2. Parameter validation, supported mandatory presence, numbers range check and regex patterns check;
3. Use Subcommands of a program;
4. Program documentation generation (i.e. embeded help)
5. Reading parameter defaults from appSettings (yes, I know that appSettings is deprecated);
6. Reading parameters from environment variables;
7. Request missing or special/secret parameters interactively;
8. Basic support for secret parameters that could be passed to program either via environment variable or interactively and it's value never appears in the program output like help generation.
9. Embedded localization support through implementation of Cli.LocalizedLitteralls interface;
10. Syntax sugar to simplify Main() method implementation using SimpleCommandLine / MultiCommandLine classes.


In details:

1. Parsing command line and mapping them to the fields of the provided class (or classes) using .NET reflection mechanisms.

	i.e. arguments of program provided in command line 
	
		> prog.exe -f 123

	maps to 

		public class Prog 
		{
			[Cli.Named('f')]
			public bool Flag = false;
		
			[Cli.Positional]
			public int Number = 0;
		}

	So that command line parsing should looks like this:

		Program p = new Prog();
		Cli.ParseCommandLine(args, p);
	
	see Sample00_Simple project for the sample with example of using Cli.ParseCommandLine() method and enums parsing.

	Supported both named and positional parameters mapping. For reading named parameters apply Cli.Named attribute to the field but for reading positional parameters apply Cli.Positonal attribute

	For named parameters, although you can specify argument name explicitly, the name of fields itself is considered as name of argument to search with command line arguments with a little translation of PascalCase to kebab-case.
	That means the field value:

		[Cli.Named]
		public int PortNumber
	
	should be provided within command line arguments in the following way:

		$ prog1.exe --port-number 123

	For sure the extra attribute Cli.RestOfArguments for Cli.Positional supported:

        [Cli.Positional]
        [Cli.RestOfArguments]
        [Cli.Required]
        public FileInfo[] FileName = {}

		$ prog1.exe ~/*.txt

	The supported data types are the following:
	- any value based types supported by automatic conversion from string via Convert.ChangeType(string, Type);

		[Cli.Named]
		public uint One = 1;

		[Cli.Named]
		public double Two = 2.0;

		$ prog1 --one 1 --two 2.5 

	- the field with bool type is always considered as a flag that sets to true if provided in command line w/o extra args i.e.:

	    [Cli.Named('A')]
		public bool PrintAllDetails = false;

		$ prog1 -A 

		also you can use long version of the flag name:

		$ prog1 --print-all-details 
	
	- additionally supported for reading DataTime via call
		converted = DateTime.Parse(strArgValue, CultureInfo.CurrentCulture, DateTimeStyles.AllowWhiteSpaces | DateTimeStyles.AssumeLocal)

	  and DataTimeOffset via
        converted = DateTimeOffset.Parse(
           strArgValue, CultureInfo.CurrentCulture, DateTimeStyles.AllowWhiteSpaces | DateTimeStyles.AssumeLocal);

		[Cli.Named]
		public DataTimeOffset LastUpdateDate = DateTimeOffset.UtcNow;

		$ prog1 --last-update-time '2005-01-01T10:00:00Z'


	  any enums via Enum.Parse(targetType, strArgValue, true) see sample Sample00_Simple 

	    [Cli.Named('O')]
        public Option Option = Option.First;

		$ ./prog1.exe -O Second

	  and System.IO.FileInfo and System.Net.IPHostEntry

        [Cli.Positional]
        [Cli.RestOfArguments]
        public FileInfo[] FileName = { };

		$ prog1 ~/*.*

	  and arrays, the values should be provided by coma separated string 
	  
        [Cli.Positional]
        public int[] PortNumberToScan = {}
	  

		$ prog1.exe "443,8443,80,8080,8081"

	  and even arrays of enums 

	    public enum Option { First, Second };

		[Cli.Positional]
        public Option[] Options = {} 

		$ prog1.exe "First,Second"

	- see Cli.ConvertArgumentStringToSingleObject() method for details

2. Parameter validation, supported mandatory presence, numbers range check and regex patterns check 
through using Cli.AllowedRegexPattern and Cli.AllowedRange attributes

        [Cli.AllowedRange(1001, 65535)]
        public int Port = 1001;

        [Cli.AllowedRagexPattern("\d+\.\d+\.\d+\.\d+")]
        public string IPAddress = "128.0.0.1";

3. Use Subcommands of program through implementing interface Cli.ICommand and using method ICommand Cli.ParseCommandLine(String[] args, ICommand[] commands)

4. Automatic documentation generation through support of using Cli.Doc attribute to annotate fields and classes and using methods Cli.PrintUsage() / Cli.PrintCommandUsage().
   Additionally attributes Cli.SampleValue and Cli.GenerateSample helps generate reasonable samples in the output of Cli.PrintUsage();
   For sure Cli.AllowedRegexPattern and Cli.AllowedRange included in argument description of the generated documentation;

		[Cli.Doc(@"The test program documentation goes here")]
		[Cli.GenerateSample]
		internal class Program
		{
			[Cli.Doc("Connecting to specific IP port")]
			[Cli.SampleValue("5555")]
			[Cli.AllowedRange(1001, 65535)]
			public int Port = 0;

		}

		...

        Cli.PrintUsage(program);

5. Reading argument defaults from appSettings section of app.config (with support of cross refs via [[Cli.param]] annotation)

	<?xml version="1.0" encoding="utf-8" ?>
    <configuration>

	<appSettings>
		<add key="Cli.arg1"
			 value="123"/>
	    <!-- xref to Cli.arg1 -->
		<add key="Cli.arg2"
			 value="aaa[[Cli.arg1]]bbb"/>

6. Reading argument value from environment variables if field is annotated with attribute Cli.EnvironmentVariable

        [Cli.EnvironmentVariable("MASTER_KEY")]
        public string MasterKey = string.Empty;       

		# could be running in Linux environment as the following

		$ MASTER_KEY=password123 mono prog1.exe
7. Reading argument value interactively if field is annotated with attribute Cli.Interactive

        [Cli.Interactive("Please enter master key", false)]
        [Cli.Required]
        [Cli.Secret]
        public string MasterKey = string.Empty;

		This argument will be requested automatically during Cli.ParseCommandLine()

		>.\Sample03_Interactive.exe
		Please enter master key:
		   - the data type is [string]
		   - is required to provide
		   - the value is a secret
		   - press Ctrl-C to interrupt
		> *****



8. Basic support for secrets. The attribute Cli.Secret if applied prevents displaying of it's value in generated help, samples and in the interactive communication.
   
        [Cli.Doc("Master key to decrypt secrets stored within configuration")]
        [Cli.Interactive("Please enter master key", false)]
        [Cli.Secret]
        [Cli.Required]
        public string MasterKey = string.Empty;     

		...


9. Embedded localization support through implementation of Cli.LocalizedLitterals interface within Cli.cs (no extra resources needed)

10. Use of SimpleCommandLine and MultiCommandLine classes to simplify Main() method implementation:
	See the sample Sample02_RestOfArguments:

        public static void Main(string[] args)
        {
            try
            {
                var p = new Program();
                new Cli.SimpleCommandLine(p).ParseArgs(args).Exec();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }

   and with support of program subcommands (see Sample01_TcpServerAndClient):

        public static void Main(string[] args)
        {
            try
            {
                Program program = new Program();

                Cli.ICommand[] commands =
                {
                    new TcpServerCommand(),
                    new TcpProducerCommand(),
                };

                new Cli.MultiCommandLine(program, commands).ParseArgs(args).Exec();
            }
            catch (Exception ex)
            { 
                Console.WriteLine(ex.ToString());
            }
        }


TODO:

10. Deny reading of Secret parameters from appSettings 

10.1. Support reading of encrypted values 

	[Cli.Encrypted(Algorithm=AES, Key_EV="MASTER_KEY", IV_EV="MASTER_KEY_IV")]
	public string Password = string.Empty;

	[Cli.Encrypted]
	public string Password = string.Empty;


9. String length validation for array or string data types

	[Cli.AllowedLength(1, 5)]
	public int[] PortsToListen = { 5555, 7777 };


	[Cli.AllowedLength(3, 8)]
	[Cli.Secret]
	[Cli.EnvironmentVariable]
	public string MasterKey;

8. Show GUI version of interactive user interface in case the command line is omitted i.e. the simple form that is representing controls for each class field to allow user enter the values;
- Text box for simple entry
- Combox box for enums
- List box for flagged enums


7. Change the inner architecture in the following way:
- The should be functional class on the each aspect that is defined by attribute. 
- The following aspects should be defined:
	FieldValidation -> RangeValidation / PatternValidation / Requirement (should be organized in the chain of responsibilities)
	 - documentation for the argument help
	 - validation itself
	ValueSource -> AppSettings / Command line / Environment variables / Interactive (should be organized in the chain of responsibilities)
	 - take the string value by the field name
    TypeConverters (should be organized in the chain of responsibilities)
	 - converts string value to different field types including arrays and enums
	 - converts object value to string value for showing 
	DocumentationSource -> Doc / SampleValue / Secret
	 - take the string value by the field name
	SpecialFilters -> Secret
	 - filter the value before reporting it in docs
	ArgumentList builder 
	 - walks through the class and enumerate it's fields with attached validators, sources and documentation
	etc

6. In case of validation error the ParseArgumentException should have the information at which source (i.e. command line arguments or app settings or environment variables) the wrong string value has been detected;

5. In case the field have several options to read values i.e. from appsettings (any of them) or command line or env vars, read each source in the order 1) app settings -> 2) env vars -> 3) command line args and each new read should override 
the previous one but only the last invalid value stops the execution (all others just generate warnings);

4. [v] Implement --full-doc option instead of separate HelpType.Quick/Full for -h/--help options that should say about all commands with samples, app settings and supported environment variables;

3. Support reading argument values from the binary or text file with parameters path and maximum file size i.e.

	[Cli.FileContent("/var/secrets/private_key.der", 65535)]
	public MemoryStream PrivateKey;

2. [v] use nameof(param) instead of explicitly written string in argument of ArgumentNullException();

1. [v] Print only interactive and appsettings arguments in the help output

PS C:\Users\andrey.larcev\Projects\CliLib2\Sample03_Interactive\bin\Debug> .\Sample03_Interactive.exe -h
Command line provided:
> Sample03_Interactive.exe -h
Usage: > Sample03_Interactive.exe [-h|--help] | [-v|--version] | [--print-app-settings] | [args] [-A|--print-args]
   - The test program to demo using interactive input and environment variables
Sample: > Sample03_Interactive.exe


 [-A|--print-args]
   - Print given arguments before execution
   - the data type is [boolean]
   - optional, default value is False
 (master-key)>
   - Master key to decrypt secrets that stored within app.config
   - the data type is [string]
   - is required to provide!
   - allowed regex pattern is "^.{8,}$"
   - could be requested interactively
   - could be passed via environment variable $MASTER_KEY
   - the value is a secret
 appSettings/Cli.*.connection-password
   - Connection password stored within app.config
   - the data type is [string]
   - is required to provide!
   - the value is a secret
   - could be specified in app.config / appSettings
