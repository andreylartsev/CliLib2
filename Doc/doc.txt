DESCRIPTION:

A single file CLI (Command Line Interface) library, similar to picocli but written in C#.
The focus is on wider compatibility and minimization of external dependencies.
The key part of functionality is replacement of imperative programming with a declarative one using attribute annotations.
Ability use the same source i.e. attribute annotations on the fields and classes to parse the command line and generate documentation for program.
Where possible used the approach to use the single information source for multiple purposes i.e. generate parameter names from the field names. 

Supported features:

1. Parsing command line arguments, supported both named and positional parameters;
2. Parameter validation, supported mandatory presence, allowed range check and regex patterns;
3. Use Subcommands of a program;
4. Automatic program documentation generation;
5. Reading parameter defaults from appSettings (yes, I know that appSettings is deprecated);
6. Request missing or special parameters interactively;
7. Reading parameters from environment variables;
8. Basic support for secret parameters that could be passed to program either via environment variable or interactively and it's value never appears in the program output like help generation.
9. Embedded localization support through implementation of Cli.L10n interface;
10. Syntax sugar to simplify Main() method implementation using SimpleCommandLine / MultiCommandLine classes.


In details:

1. Parsing command line and mapping them to the fields of the provided class (or classes) using .NET reflection mechanisms.

	i.e. arguments of program provided in command line 
	
		> prog.exe -f 123

	maps to 

		public class Prog 
		{
			[Cli.Named('f')]
			public bool Flag = false;
		
			[Cli.Positional]
			public int Number = 0;
		}

	So that command line parsing should looks like this:

		Program p = new Prog();
		Cli.ParseCommandLine(args, p);
	
	see Sample00_Simple project for the sample with example of using Cli.ParseCommandLine() method and enums parsing.

	Supported both named and positional parameters mapping. For reading named parameters apply Cli.Named attribute to the field but for reading positional parameters apply Cli.Positonal attribute

	For named parameters, although you can specify argument name explicitly, the name of fields itself is considered as name of argument to search with command line arguments with a little translation of PascalCase to kebab-case.
	That means the field value:

		[Cli.Named]
		public int PortNumber
	
	should be provided within command line arguments in the following way:

		$ prog1.exe --port-number 123

	For sure the extra attribute Cli.RestOfArguments for Cli.Positional supported:

        [Cli.Positional]
        [Cli.RestOfArguments]
        [Cli.Required]
        public FileInfo[] FileName = {}

		$ prog1.exe ~/*.txt

	The supported data types are the following:
	- any value based types supported automatic conversion from string via Convert.ChangeType(string, Type);

		[Cli.Named]
		public uint One = 1;

		[Cli.Named]
		public double Two = 2.0;

		$ prog1 --one 1 --two 2.5 

	- the field with bool type is always considered as a flag that sets to true if provided w/o extra args i.e.

	    [Cli.Named('A')]
		public bool PrintAllDetails = false;

		$ prog1 -A 

		or

		$ prog1 --print-all-details 
	
	- additionally supported for reading DataTime via call
		converted = DateTime.Parse(strArgValue, CultureInfo.CurrentCulture, DateTimeStyles.AllowWhiteSpaces | DateTimeStyles.AssumeLocal)

	  and DataTimeOffset via
        converted = DateTimeOffset.Parse(
           strArgValue, CultureInfo.CurrentCulture, DateTimeStyles.AllowWhiteSpaces | DateTimeStyles.AssumeLocal);

		[Cli.Named]
		public DataTimeOffset LastUpdateDate = DateTimeOffset.UtcNow;

		$ prog1 --last-update-time '2005-01-01T10:00:00Z'


	  any enums via Enum.Parse(targetType, strArgValue, true) see sample Sample00_Simple 

	    [Cli.Named('O')]
        public Option Option = Option.First;

		$ ./prog1.exe -O Second

	  and System.IO.FileInfo and System.Net.IPHostEntry

        [Cli.Positional]
        [Cli.RestOfArguments]
        public FileInfo[] FileName = { };

		$ prog1 ~/*.*

	  and arrays, the values should be provided by coma separated string 
	  
        [Cli.Positional]
        public int[] PortNumberToScan = {}
	  

		$ prog1.exe "443,8443,80,8080,8081"

	  and even arrays of enums 

	    public enum Option { First, Second };

		[Cli.Positional]
        public Option[] Options = {} 

		$ prog1.exe "First,Second"

	- see Cli.ConvertArgumentStringToSingleObject() method for details

2. Automatic validation through using Cli.AllowedRegexPattern and Cli.AllowedRange attributes

        [Cli.AllowedRange(1001, 65535)]
        public int Port = 1001;

        [Cli.AllowedRagexPattern("\d+\.\d+\.\d+\.\d+")]
        public string IPAddress = "128.0.0.1";

3. Use Subcommands of program through implementing interface Cli.ICommand and using method ICommand Cli.ParseCommandLine(String[] args, ICommand[] commands)

4. Automatic documentation generation through support of using Cli.Doc attribute to annotate fields and classes and using methods Cli.PrintUsage() / Cli.PrintCommandUsage().
   Additionally attributes Cli.SampleValue and Cli.GenerateSample helps generate reasonable samples in the output of Cli.PrintUsage();
   For sure Cli.AllowedRegexPattern and Cli.AllowedRange included in argument description of the generated documentation;

		[Cli.Doc(@"The test program documentation goes here")]
		[Cli.GenerateSample]
		internal class Program
		{
			[Cli.Doc("Connecting to specific IP port")]
			[Cli.SampleValue("5555")]
			[Cli.AllowedRange(1001, 65535)]
			public int Port = 0;

		}

		...

        Cli.PrintUsage(program);

5. Reading argument defaults from appSettings section of app.config (with support of cross refs via [[Cli.param]] annotation)

	<?xml version="1.0" encoding="utf-8" ?>
    <configuration>

	<appSettings>
		<add key="Cli.arg1"
			 value="123"/>
	    <!-- xref to Cli.arg1 -->
		<add key="Cli.arg2"
			 value="aaa[[Cli.arg1]]bbb"/>


6. Reading argument value interactively through the using of Cli.Interactive annotation attribute for field

        [Cli.Interactive("Please enter master key", false)]
        [Cli.Required]
        public string MasterKey = string.Empty;

		This argument will be requested automatically during Cli.ParseCommandLine()

		>.\Sample03_Interactive.exe
		Please enter master key:
		   - the data type is [string]
		   - is required to provide
		   - the value is a secret
		   - press Ctrl-C to interrupt
		> *****

7. Reading argument value from environment variables through the using of Cli.EnvironmentVariable annotation attribute for field

        [Cli.EnvironmentVariable("MASTER_KEY")]
        public string MasterKey = string.Empty;       

		# could be running in Linux environment as the following

		$ MASTER_KEY=password123 mono prog1.exe

8. Basic support for secrets. The attribute Cli.Secret if applied prevent display of it's value in generated documentation and samples.
   Also it turns reading of argument interactively into secret mode with masking user's input with stars

        [Cli.Doc("Master key to decrypt secrets stored within configuration")]
        [Cli.Interactive("Please enter master key", false)]
        [Cli.Secret]
        [Cli.Required]
        public string MasterKey = string.Empty;     

		...


9. Embedded localization support through implementation of Cli.L10n interface within Cli.cs (no extra resources needed)

10. Use of SimpleCommandLine and MultiCommandLine classes to simplify Main() method implementation:
	See the sample Sample02_RestOfArguments:

        public static void Main(string[] args)
        {
            try
            {
                var p = new Program();
                new Cli.SimpleCommandLine(p).ParseArgs(args).Exec();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }

   and with support of program subcommands (see Sample01_TcpServerAndClient):

        public static void Main(string[] args)
        {
            try
            {
                Program program = new Program();

                Cli.ICommand[] commands =
                {
                    new TcpServerCommand(),
                    new TcpProducerCommand(),
                };

                new Cli.MultiCommandLine(program, commands).ParseArgs(args).Exec();
            }
            catch (Exception ex)
            { 
                Console.WriteLine(ex.ToString());
            }
        }


TODO:

1. print only interactive and appsettings arguments in the help output

==
C:\Users\andrey.larcev\Projects\CliLib2\Sample03_Interactive\bin\Debug>.\Sample03_Interactive.exe --help
Command line provided:
> Sample03_Interactive.exe --help
Usage: > Sample03_Interactive.exe [-h|--help] | [-v|--version] | [--print-app-settings] | [args] [-A|--print-args]
   - The test program to demo using interactive input and environment variables

 [-A|--print-args]
   - Print given arguments before execution
   - the data type is [boolean]
   - optional, default value is True

==
C:\Users\andrey.larcev\Projects\CliLib2\Sample03_Interactive\bin\Debug>.\Sample03_Interactive.exe --help
Command line provided:
> Sample03_Interactive.exe --help
Usage: > Sample03_Interactive.exe [-h|--help] | [-v|--version] | [--print-app-settings] | [args] [-A|--print-args]
   - The test program to demo using interactive input and environment variables

 [-A|--print-args]
   - Print given arguments before execution
   - the data type is [boolean]
   - optional, default value is True

 master-key
   - Master key to decrypt secrets stored within configuration
   - requested interactively
   - is required to provide
   - could be passed via environment variable $MASTER_KEY
   - the data type is [string]

 connection-password 
   - Master key to decrypt secrets stored within configuration
   - Taken from appSettings/Cli.connection-password parameter of app.config
   - is required to provide
   - could be passed via environment variable $MASTER_KEY
   - the data type is [string]

